# Property vs Field

**Field vs Properties**

**=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=**

이 글은 저의 짧은 지식으로 작성 되었구요. 만약 다른 사이트에 배포하실 때에는 출처는 꼭 밝혀 주세요. 안 그러면 미워할꼬야.. 혹시 강좌 내용 중 의심나는 부분이 있으면 주저하지 마시고 좀더 나은 강좌를 위해 바로 위의 메일로 리포트해주세요. 리포트한번 해주시는데에 대해 뽀뽀한번..!!^^

 

**우리가 꿈꾸는 세상..~~^^** **by the .NET, of the .NET, for the .NET**

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

안녕하세요. cache임다. 오늘은 프로퍼티에 대해 알아보도록 하죠. 사실 그리 어려운 개념은 아니죠. 그렇지만 이 개념이 생소하다 보니 많은 분들께서 어렵게 생각하시는 것 같네요.

자 그럼 오늘은 이 프로퍼티라는 놈들에 대해 까발리는 시간을 가져보도록 합죠..^^

 

C#에서의 프로퍼티라는 놈은 Visual Basic의 영향을 받아 새로 추가된 기능으로 필드와 마찬가지로 특성(?)을 구현하는데 사용됩니다. 그래서리 많은 C/C++나 Java 프로그래머들께서 요놈을 처음 접했을 때 생소해 하시는게 사실이죠. 하지만 이 프로퍼티라는 놈을 간파하신 분들께서는 애플리케이션 작성시 이 프로퍼티라는 놈을 아주 애용하게 될 것이라고 생각됩니다.

 

자 그럼 요넘의 실체를 까발리기 전에 요넘과 비슷한 필드라는 놈에 대해 알아봅죠. 객체지향 프로그래밍에서 클래스가 가장 큰 단위이죠. 클래스는 그 내부에 많은 것들을 쓸어 담고 있죠. 그 중에 하나가 필드라는 놈입니다. 필드란 클래스 멤버 변수로써 클래스 내부에 글로벌하게 선언된 변수라고 정의하면 될 듯하네요.

 

사용 예를 한번 들어보죠. 백문이 불여일견이라 했나여..?^^

아래는 필드를 선언하여 초기화까지 겸한 코드입니다. 다들 많이들 보셨죠..? ^^

public class MyClass{
public int count =10 ;  // 요넘이 필드

}

그리고 우리가 위에 선언한 필드에 접근하기 위한 코드를 아래와 같이 한번 들어보죠.

public class MainClass {

 public static void Main()
 {
  MyClass mc = new MyClass();      // 접근하기 위한 인스턴스 생성
  System.Console.WriteLine(mc.Count) ;  // 필드값 참조부분
  mc.Count=20 ;  // 필드값 세팅부분
  System.Console.WriteLine(mc.Count);  // 새로이 세팅된 값 참조부분
 }
}

위와 같은 경우는 아주 쉽고, 매우 직관적이죠. 허나 위와 같은 경우는 아주 위험 부담이 많이 가는 코드이죠. 만약 해당 필드에 다이렉트로 접근한다고 하면 아주 곤란한 경우를 많이 당할 것이라 생각됩니다. 예를 들어보죠. 은행의 계좌번호라등가 아니면 패스워드 같은 경우 사용자가 직접 접근할 수 있게 클래스를 설계하였다면 난리가 나겠죠…?

객체지향 프로그래밍의 기본 관례를 따르자면 멤버 필드들은 관례적으로 private로 선언되어야 하구, 또 이 멤버 필드들에 접근하기 위한 유일한 대안으로는 public methods 뿐이죠.

Java의 경우를 함 살펴보죠. Java는 위와 같은 룰을 따르기 위해 Get?? 메소드와 Set?? 메소드를 이용하여 private 필드들에 접근하고 있죠. 말만 주저리 주저리 하는 것 보다 예를 한번 들어보죠. 아래는 Java 스타일로 위에 언급한 룰을 따른 예입니다.

public class MyClass{
private int count =10 ;  // 요넘이 필드

//Get method
public int GetCount()
{
  return count;
}
//Set method
public void SetCount (int n)
{
  this.count = n;
}

}

public class MainClass {

 public static void Main()
 {
  MyClass mc = new MyClass();  // 접근하기 위한 인스턴스 생성
  System.Console.WriteLine(mc.GetCount( )) ;  // 필드값 참조부분
  mc.SetCount (20) ;  // 필드값 세팅부분

System.Console.WriteLine(mc.GetCount( ));  // 새로이 세팅된 값 참조부분

}
}

위와 같이 사용하면 객체지향 프로그래밍의 기본적인 관례를 따르면서 아주 유용하게 사용되리라 생각될 것입니다. 허나 이러한 방법을 사용함으로써 발생하는 새로운 문제가 있죠. 만약 위와 같이 짜잘(?)한 클래스가 아닌 아주 거대한 클래스를 설계한다고 해보죠. 우리가 설계하고자 하는 이 거대한 클래스 내에는 아주 많은 필드들이 존재할 것이고 또 그것들을 핸들링하기 위한 Get?? 메소드들과 Set?? 메소드들이 무수히 존재하게 될 것입니다.

이렇게 되면 자연히 프로그래머가 이들 메소드들을 식별해 내기는 여간 힘든 작업이 될 것은 자명한 일이 될 것이고 또한 대부분의 경우 값을 참조하기 위한 Get?? 메소드와 값을 세팅하기 위한 Set?? 메소드가 서로 다른 위치에서 사용되어 프로그래머들은 각각의 필드가 어디에서 사용되었고, 어떤 부분에서 세팅되었는가를 찾기 위해 소스 코드를 눈을 부릅뜨고 뒤져야 하는 지경까지 이를 것이다. 

다시 말해 위와 같이 작성하면 객체지향 프로그래밍의 기본 스타일은 아주 성실히 이행하고 있으나 대형 프로젝트에는 걸맞지 않은 개념이라는 것입니다. 현재 대부분의 프로젝트가 위와 같은 스타일로 진행되리라 생각되어집니다. 이 때문에 현재 죽어나는 사람들은 이를 작성한 프로그래머이죠. 몇날 몇일을 밤을 꼬박세워 천신만코 끝에 작성한 코드를 몇 달, 심지어는 몇 주가 지난 후에 그 코드를 유지보수 하고자 할 때 해당 변수가 어느 부분에서 참조되었고, 또 어느 부분에서 새로이 세팅되었는지를 찾아내는지에 많은 시간을 투자하신 경험을 대부분의 프로그래머들이 경험한 바 있을 것입니다.

위와 같은 문제점을 깨닫고 이 문제점을 해결하기 위해 마이크로소프트사가 제안한 개념이 프로퍼티라는 놈입니다. 요넘도 사용은 멤버 필드와 같이 간단하게 사용할 수 있지만 그 실제 내부 기능은 함수들로 이루어져 있으므로 다양한 능력을 발휘할 수 있을 것입니다. 간단히 말하자면 사용은 더 간편하게, 기능은 더 강력하게 만들어 주는 것들이지요.

기본 형식은 아래와 같습니다.

```c#
<access modifier> <return type> <Property name> {
 //optional
 get
 {
  ....
 }
 //optional
 set
 {
  ...
 }
}
```





그럼 실제로 자바스타일이 가졌던 문제점을 C#에서는 프로퍼티라는 넘을 사용해 어떻게 해결하고 있는지 함 알아볼까요..? 예제를 들어보죠.
```c#
public class MyClass{
 private int count =10 ;  // 요넘이 필드
 
 // 프로퍼티 정의 부분
 public int Count
 {
  // 필드값을 참조하기 위한 부분
  get
  {
   return count;     //return the value
  }
  // 필드값을 세팅하기 위한 부분
  set
  {
   this.count = value; // set the value
  }
 }
```
```c#
public class MainClass {
 public static void Main()
 {
  MyClass mc = new MyClass();  // 필드값을 다루기위한 인스턴스 생성
  System.Console.WriteLine(mc.Count) ;  // 필드값 참조부분
  mc.Count = 20 ;  // 필드값 세팅부분
  System.Console.WriteLine(mc.Count);  //새로이 세팅된 값 참조부분
 }
}
```
위의 예를 한번 살펴보죠. 어디서 눈에 익은 스타일이 아닌가요..? 제가 앞에서 처음 언급했던 필드를 사용하는 예제의 스타일과 똑같습니다. 그럼 이게 무엇을 의미할 까요..?
이쯤되면 아마 간파하신 분들도 계시리라 생각됩니다. 앞에서 프로퍼티에 대해 정의한 바와 같이 겉 모습은 필드처럼 사용되어 좀더 간편하게 사용되어 질 수 있는 반면에, 실제 내부는 메소드처럼 사용되어 좀더 강력한 기능을 제공하고 있다는 거죠. 즉, 필드와는 달리 프로퍼티는 get/set 접근자를 통해 멤버 변수에 접근하게 함으로써 클래스 내부의 데이터를 외부의 접근으로부터 보호할 수 있다는 겁죠.

아주 멋진넘이지 않습니까..? 또 위에서 언급 했었던 자바스타일의 예와는 달리 해당 필드를 참조하는 부분과 세팅되는 부분을 같은 위치에 놓여지게 함으로써 좀더 쉽게 필드들을 컨트롤 할 수 있게 함으로써 프로그래머에게 좀더 향상된 가독성를 제공해 주고 잇다는 거죠. 요넘의 사용만으로도 프로그래머는 프로그램 작성이나 유지, 보수시에 좀더 효율적으로 일을 할 수 있다는 거죠. 이만하면 정말 매력적이지 않나요..?

그럼 실제 사용되어 지는 코드를 함 비교해 볼까요..?

아래는 전형적인 자바스타일의 코드입니다.

System.Console.WriteLine(mc.GetCount( )) ;  // 필드값 참조부분
mc.SetCount (20) ;  // 필드값 세팅부분
System.Console.WriteLine(mc.GetCount( ));  // 새로이 세팅된 값 참조부분

 

아래는 위의 자바스타일과 같은 의미의 C# 코드입니다.

System.Console.WriteLine(mc.Count) ;  // 필드값 참조부분
mc.Count = 20 ;  // 필드값 세팅부분
System.Console.WriteLine(mc.Count);  //새로이 세팅된 값 참조부분

 

위와 같이 두 경우를 비교해 보면, C#에서 프로퍼티라는 놈을 사용하여 구현하여 놓은 코드가 좀더 사용자에게 좀더 직관적으로 다가올 거라고 생각됩니다. 그렇지 않나요..?

그럼 이쯤해서 실제 프로퍼티의 내부 구현을 담당하는 넘들에 대해 언급하여 보죠. 아마 C#관련 책에서 자세히 다루어 지고 있는 부분이라 생각되어 그리 세세히는 다루지 않겠습니다.

프로퍼티는 get, set이라 불리는 두 접근자가 실제 해당 필드를 컨트롤하고 있죠. 또 우리는 이 두 놈중 하나만 사용하여 읽기 전용의 필드를 만들 수도 있고 쓰기 전용의 필드도 만들 수 있답니다. 물론 전자는 get프로퍼티를 의미하고, 후자는 set프로퍼티를 의미하고 있습니다.

get – 해당 필드를 읽기 전용으로 접근하기 위한 접근자

만약 은행 클래스를 작성한다고 생각해 보죠. 은행 클래스에서 클라이언트에 의해서 변경되어서는 안되는 부분이 여러 개 있을 것입니다. 그 중 대표적으로 은행계좌번호 같은 경우는 사용자에 의해서 변경되어서는 안될 필드중의 하나이죠. 바로 이때 get프로퍼티가 아주 유용하게 사용될 것입니다. 은행계좌번호 필드를 핸들링하기 위한 프로퍼티를 읽기 전용으로 get 프로퍼티만 구현해 준다면 클라이언트에 의해서 변경되어 지는 것을 사전에 차단할 수 있다는 것이죠.

set – 해당 필드를 쓰기 전용으로 접근하기 위한 접근자.

set 프로퍼티 내에서는 value라는 키워드를 사용하여 전달되어진 값에 접근할 수 있죠. 전달되어진 값을 접근하기 위해서는 항상 value라는 키워드를 사용해야 한답니다. 그리고 이 프로퍼티 내부에서는 사전에 value값을 체크하여 해당 프로퍼티의 사용 여부를 결정할 수도 있답니다.

예를 들어보죠, 만약 달력 클래스를 설계한다고 해보죠. 분명히 month필드는 항상 1에서 12까지의 숫자중의 하나를 가져야 할 것입니다. 아래와 같이 사용함으로 유효범위가 아닌 경우 해당 프로퍼티의 잘못된 사용을 제어할 수 있는 기능도 담당할 수 있죠. 아주 유용한 넘이죠.. 당연한 가여..? 물론 get 프로퍼티의 경우도 제어문을 이용하여 상황에 따라 다른 리턴값을 리턴하도록 제어할 수도 있구요.
```c#
public int Month
{
 set
 {
  if(value>0 && value<13)      // 유효범위 검사부분
   this.month=value ;
 }
}
```
여기까지 읽어보시면서 의문이 생기지 않으셨나여..? value 변수는 어디에서 온 것일까..? 또 컴파일러가 mc.Count와 같은 구문으로 해당 필드에 어쩌고 접근하고 있을까..? 이런 의문은 당연하다고 생각되어집니다. 이를 설명하기 위해서는 컴파일러에 의해 생성되어진 IL코드를 뒤져볼 필요가 있습니다.

```c#
class Address {
   protected string zipCode;   
   public string ZipCode   {      
      get   {
         return zipCode;
      }      .      .      .   
   }
}
```

위의 코드는 Inside C#에 사용되었던 예제입니다. Address 클래스의 멤버 변수인 zipCode는 읽기 전용으로 사용되고 있군요. 자세한 설명은 생략하겠습니다. 위에서 계속해온 예기라서 짜증내실 까봐…^^

```
.method public hidebysig specialname instance string        
get_ZipCode() cil managed{  // Code size       11 (0xb)  
.maxstack  1  .locals ([0] string _Vb_t_$00000003$00000000)  IL_0000:  
ldarg.0  IL_0001:  ldfld      
string 
Address::zipCode  IL_0006:  
stloc.0  IL_0007:  
br.s       IL_0009  IL_0009:  
ldloc.0  IL_000a:  ret} // end of method Address::get_ZipCode
```


위는 IL 코드의 내부입니다. 이 코드를 자세히 살펴보시기 바랍니다. 프로퍼티 즉 해당 필드에 접근하기 위한 접근 메소드는 IL코드상에서 다른 메소들과 쉽게 구별됩니다. 보통 컴파일러는 프로퍼티 앞에 get 프로퍼티의 경우에는 get_이라는 접두사를, set 프로퍼티의 경우는 set_이라는 접두사를 붙여줍니다. 이 떄문에 결과적으로, 다음의 코드는 get_ZipCode를 호출하는 것입니다.

String str = addr.ZipCode; // This calls Address:: get_ZipCode

허나 IL코드 상에 get_ZipCode라는 메소드가 존재한다하여 아래와 같이 IL코드를 명시적으로 부르는 것은 허용치 않습니다.

String str = addr.get_ZipCode;

이해 가시죠…? 일종의 프로토콜이라고 생각하시면 됩니다. 즉, CLR과 내가 프로그램 작성시 따라야 하는 규칙이라고 생각하셔도 될 듯 하네요.

set프로퍼티도 위와 유사한 방식으로 동작하고 있습니다. 허나 사용 방법의 차이는 있겠죠. 이에 대한 자세한 설명은 피하겠습니다. 참고로 set프로퍼티의 IL코드를 하나 보여 드리겠습니다. 이 코드도 Inside C#이라는 책에 사용되었던 예제 코드입니다.

```c#
public string ZipCode   {      ...      
set      {         // Validate value against some datastore. 
zipCode = value;         // Update city based on validated zipCode.      
}  
}
```

위의 코드에 해당하는 IL코드입니다.

```
.method public hidebysig specialname instance void         
set_ZipCode (string 'value') cil managed{  // Code size       
8 (0x8)  .maxstack  8  IL_0000:  
ldarg.0  IL_0001:  
ldarg.1  IL_0002:  
stfld      string Address::zipCode  IL_0007:  ret} // end of method Address::set_ZipCode
```

위의 코드를 보시면 컴파일러 자체적으로 value라는 넘을 자동으로 생성해 주어 전달되어진 값에 접근할 수 있게 하고 있죠.

지금까지 프로퍼티에 대해 살펴보았습니다. 그럼 마지막으로 멤버 변수(필드)와 프로퍼티, 멤버 함수와 프로퍼티 간의 차이점과 유사성에 대해 알아볼 까요..?

먼저 멤버 변수와 프로퍼티 간의 차이점과 유사성에 대해 알아보죠. 프로퍼티를 이렇게 정의해도 될 듯 하네요. get 접근자를 이용하여 단순히 저장된 값이 아닌 이미 계산되어진 값을 반환 할 수 있는 클래스 멤버..!!

프로퍼티는 멤버 변수와 마찬가지로 동일한 형태의 접근자를 제공합니다. 즉, public, protected, private, internal이 사용 가능하다는 예기겠죠.. 또한 static 프로퍼티도 생성이 가능하답니다. 이 둘간의 차이점이 있다면 프로퍼티는 멤버 변수와 같이 값이 아니라는 거죠. 그래서 프로퍼티는 주소도 가질 수 없습니다. 예를 들면, ref, out으로 선언된 인자에 대해 실인자로 사용할 수는 없겠죠. 당연하나여..?^^

또 필드와는 달리 프로퍼티는 get/set 접근자를 통해 멤버 변수에 접근하게 함으로써 클래스 내부의 데이터를 외부의 접근으로부터 보호할 수 있다는 겁죠.

다음으로 멤버 함수와 프로퍼티 간의 차이점과 유사성에 대해 알아 보자면,,,
프로퍼티는 함수와 마찬가지로 실행해야 할 코드를 포함합니다. 또virtual, abstract, override로 선언이 가능합니다. 엄밀히 말하면 프로퍼티도 역시 메소드라고 생각하시면 될 듯 하네요. 이 둘 간의 차이점이 있다면 문법적인 차이가 있겠죠.

대표적인 예로 프로퍼티는 호출시 변수처럼 사용되어서 인자리스트를 요구하지 않겠죠. 또 프로퍼티는 get 접근자의 경우 void형이 되어서는 안되구요. Set 접근자의 경우는 인자를 받지 않거나 오직 한 개의 인자를 value라는 예약어로 받어야 한다는 겁죠.

지금까지 주저리 주저리 살펴 프로퍼티라는 놈에 대해 살펴보았습니다. 제가 글발이 없어서 명쾌하게 설명하지 못한 점은 미리 사죄드리구요. 위의 내용에 대한 질문 사항이나 잘못된 부분이 있으시면 가차없이 리포트 해주세요. 상호간의 좀더 발전되어 질수 있는 계기가 되리라 생각됩니다.

**[출처]** [[C#\] Field vs Properties 강좌](http://blog.naver.com/saga111/120015999769)|**작성자** [메탈기어](http://blog.naver.com/saga111)